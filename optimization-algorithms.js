class CuttingItem1D{constructor(id,length,quantity){this.id = id;this.length = Math.round(length);this.quantity = quantity;this.placed = false;this.position = 0;this.barId = '';this.originalLength = Math.round(length);this.originalId = this.extractOriginalId(id)}extractOriginalId(itemId){const match = itemId.match(/^(.+)-(\d+)$/);return match ? match[1]:itemId}}class Bar1D{constructor(id,maxLength){this.id = id;this.maxLength = Math.round(maxLength);this.items =[];this.usedLength = 0;this.remainingLength = Math.round(maxLength);this.efficiency = 0;this.wastePercentage = 0}canPlace(item){return this.remainingLength >= item.length}placeItem(item){if(this.canPlace(item)){item.placed = true;item.position = this.usedLength;item.barId = this.id;this.items.push(item);this.usedLength = Math.round(this.usedLength + item.length);this.remainingLength = Math.round(this.maxLength - this.usedLength);this.efficiency = Math.round((this.usedLength / this.maxLength)* 100);this.wastePercentage = Math.round((this.remainingLength / this.maxLength)* 100);return true}return false}getWaste(){return Math.round(this.remainingLength)}}class CuttingOptimizer1D{constructor(algorithm){this.algorithm = algorithm.toLowerCase()}optimize(items,materialLength){const startTime = Date.now();const allItems =[];items.forEach(item =>{for(let i = 0;i < item.quantity;i++){const itemId = `${item.id}-${i + 1}`;allItems.push(new CuttingItem1D(itemId,Math.round(item.length),1))}});let bars;switch(this.algorithm){case 'best-fit':bars = this.bestFitAlgorithm(allItems,Math.round(materialLength));break;case 'worst-fit':bars = this.worstFitAlgorithm(allItems,Math.round(materialLength));break;default:bars = this.firstFitAlgorithm(allItems,Math.round(materialLength))}const totalBars = bars.length;const totalItemsPlaced = bars.reduce((sum,bar)=> sum + bar.items.length,0);const totalMaterialLength = Math.round(totalBars * materialLength);const totalUsedLength = Math.round(bars.reduce((sum,bar)=> sum + bar.usedLength,0));const totalWaste = Math.round(bars.reduce((sum,bar)=> sum + bar.getWaste(),0));const overallEfficiency = Math.round(totalMaterialLength > 0 ?(totalUsedLength / totalMaterialLength)* 100 :0);return{bars,totalBars,totalItems:totalItemsPlaced,totalUsedLength,totalWaste,overallEfficiency,executionTime:Math.round(Date.now()- startTime),algorithm:this.algorithm,}}firstFitAlgorithm(items,materialLength){const sortedItems =[...items].sort((a,b)=> b.length - a.length);const bars =[];sortedItems.forEach(item =>{let placed = false;for(const bar of bars){if(bar.placeItem(item)){placed = true;break}}if(!placed){const newBar = new Bar1D(`BAR-${bars.length + 1}`,materialLength);if(newBar.placeItem(item)){bars.push(newBar)}}});return bars}bestFitAlgorithm(items,materialLength){const sortedItems =[...items].sort((a,b)=> b.length - a.length);const bars =[];for(const item of sortedItems){let bestBar = null;let bestRemaining = materialLength + 1;for(const bar of bars){if(bar.canPlace(item)){const remaining = bar.remainingLength - item.length;if(remaining >= 0 && remaining < bestRemaining){bestRemaining = remaining;bestBar = bar}}}if(bestBar){bestBar.placeItem(item)}else{const newBar = new Bar1D(`BAR-${bars.length + 1}`,materialLength);if(newBar.placeItem(item)){bars.push(newBar)}}}return bars}worstFitAlgorithm(items,materialLength){const sortedItems =[...items].sort((a,b)=> b.length - a.length);const bars =[];for(const item of sortedItems){let worstBar = null;let worstRemaining = -1;for(const bar of bars){if(bar.canPlace(item)&& bar.remainingLength > worstRemaining){worstRemaining = bar.remainingLength;worstBar = bar}}if(worstBar){worstBar.placeItem(item)}else{const newBar = new Bar1D(`BAR-${bars.length + 1}`,materialLength);if(newBar.placeItem(item)){bars.push(newBar)}}}return bars}}class CuttingItem2D{constructor(id,width,height,quantity,rotation = true){this.id = id;this.width = Math.round(width);this.height = Math.round(height);this.quantity = quantity;this.canRotate = rotation;this.placed = false;this.x = 0;this.y = 0;this.rotated = false;this.area = Math.round(width * height);this.originalWidth = Math.round(width);this.originalHeight = Math.round(height);this.originalId = this.extractOriginalId(id)}extractOriginalId(itemId){const match = itemId.match(/^(.+)-(\d+)$/);return match ? match[1]:itemId}rotate(){if(this.canRotate){[this.width,this.height]=[this.height,this.width];this.rotated = !this.rotated}}}class Plate2D{constructor(id,width,height){this.id = id;this.width = Math.round(width);this.height = Math.round(height);this.items =[];this.usedArea = 0;this.totalArea = Math.round(width * height);this.freeRects =[{x:0,y:0,width:Math.round(width),height:Math.round(height)}]}getEfficiency(){return Math.round((this.usedArea / this.totalArea)* 100)}getWasteArea(){return Math.round(this.totalArea - this.usedArea)}getWastePercentage(){return Math.round(this.totalArea > 0 ?(this.getWasteArea()/ this.totalArea)* 100 :0)}canPlace(item,x,y){if(x < 0 || y < 0 || x + item.width > this.width || y + item.height > this.height){return false}for(const placedItem of this.items){if(x < placedItem.x + placedItem.width && x + item.width > placedItem.x && y < placedItem.y + placedItem.height && y + item.height > placedItem.y){return false}}return true}placeItem(item,x,y){if(this.canPlace(item,x,y)){item.x = Math.round(x);item.y = Math.round(y);item.placed = true;this.items.push(item);this.usedArea = Math.round(this.usedArea + item.area);this.updateFreeRects(item);return true}return false}updateFreeRects(placedItem){const newFreeRects =[];for(const freeRect of this.freeRects){this.splitFreeRect(freeRect,placedItem).forEach(r => newFreeRects.push(r))}this.freeRects = newFreeRects.filter(rect => !this.isContained(rect,placedItem));this.mergeRects()}splitFreeRect(freeRect,placedItem){if(placedItem.x >= freeRect.x + freeRect.width || placedItem.x + placedItem.width <= freeRect.x || placedItem.y >= freeRect.y + freeRect.height || placedItem.y + placedItem.height <= freeRect.y){return[freeRect]}const newRects =[];if(placedItem.x > freeRect.x){newRects.push({x:freeRect.x,y:freeRect.y,width:Math.round(placedItem.x - freeRect.x),height:freeRect.height})}if(placedItem.x + placedItem.width < freeRect.x + freeRect.width){newRects.push({x:Math.round(placedItem.x + placedItem.width),y:freeRect.y,width:Math.round(freeRect.x + freeRect.width -(placedItem.x + placedItem.width)),height:freeRect.height})}if(placedItem.y > freeRect.y){newRects.push({x:freeRect.x,y:freeRect.y,width:freeRect.width,height:Math.round(placedItem.y - freeRect.y)})}if(placedItem.y + placedItem.height < freeRect.y + freeRect.height){newRects.push({x:freeRect.x,y:Math.round(placedItem.y + placedItem.height),width:freeRect.width,height:Math.round(freeRect.y + freeRect.height -(placedItem.y + placedItem.height))})}return newRects}isContained(rectA,rectB){return rectA.x >= rectB.x && rectA.y >= rectB.y && rectA.x + rectA.width <= rectB.x + rectB.width && rectA.y + rectA.height <= rectB.y + rectB.height}mergeRects(){let i = 0;while(i < this.freeRects.length){let j = i + 1;while(j < this.freeRects.length){if(this.isContained(this.freeRects[j],this.freeRects[i])){this.freeRects.splice(j,1)}else if(this.isContained(this.freeRects[i],this.freeRects[j])){this.freeRects.splice(i,1);i--;break}else{j++}}i++}}}class PlateOptimizer2D{constructor(algorithm){this.algorithm = algorithm.toUpperCase()}optimize(items,plateWidth,plateHeight){const startTime = Date.now();const allItems =[];items.forEach(item =>{for(let i = 0;i < item.quantity;i++){allItems.push(new CuttingItem2D(`${item.id}-${i + 1}`,Math.round(item.width),Math.round(item.height),1,item.rotation))}});let plates;switch(this.algorithm){case 'GUILLOTINE':case 'MAXRECTS':plates = this.bestFitBinPack(allItems,Math.round(plateWidth),Math.round(plateHeight));break;default:plates = this.simpleBinPack(allItems,Math.round(plateWidth),Math.round(plateHeight))}const totalPlates = plates.length;const totalItemsPlaced = plates.reduce((sum,p)=> sum + p.items.length,0);const totalArea = Math.round(plates.reduce((sum,p)=> sum + p.totalArea,0));const totalUsedArea = Math.round(plates.reduce((sum,p)=> sum + p.usedArea,0));const overallEfficiency = Math.round(totalArea > 0 ?(totalUsedArea / totalArea)* 100 :0);return{plates,totalPlates,totalItems:totalItemsPlaced,totalUsedArea,overallEfficiency,unplacedItems:Math.round(allItems.length - totalItemsPlaced),executionTime:Math.round(Date.now()- startTime),algorithm:this.algorithm,}}simpleBinPack(items,plateWidth,plateHeight){const plates =[];const sortedItems = items.sort((a,b)=> b.area - a.area);for(const item of sortedItems){if(item.placed)continue;let placed = false;for(const plate of plates){const pos = this.findPositionSimple(item,plate);if(pos){plate.placeItem(item,pos.x,pos.y);item.rotated = pos.rotated;placed = true;break}}if(!placed){const newPlate = new Plate2D(`PLATE-${plates.length + 1}`,plateWidth,plateHeight);const pos = this.findPositionSimple(item,newPlate);if(pos){newPlate.placeItem(item,pos.x,pos.y);item.rotated = pos.rotated;plates.push(newPlate)}}}return plates}findPositionSimple(item,plate){for(let y = 0;y <= plate.height - item.height;y++){for(let x = 0;x <= plate.width - item.width;x++){if(plate.canPlace(item,x,y)){return{x:Math.round(x),y:Math.round(y),rotated:false}}}}if(item.canRotate){item.rotate();for(let y = 0;y <= plate.height - item.height;y++){for(let x = 0;x <= plate.width - item.width;x++){if(plate.canPlace(item,x,y)){return{x:Math.round(x),y:Math.round(y),rotated:true}}}}item.rotate()}return null}bestFitBinPack(items,plateWidth,plateHeight){const plates =[];const sortedItems = items.sort((a,b)=> Math.max(b.width,b.height)- Math.max(a.width,a.height));for(const item of sortedItems){if(item.placed)continue;let bestFit = null;for(const plate of plates){const fit = this.findBestFitForPlate(item,plate);if(fit &&(!bestFit || fit.score < bestFit.score)){bestFit ={plate,...fit}}}if(bestFit){if(bestFit.rotated)item.rotate();bestFit.plate.placeItem(item,bestFit.x,bestFit.y)}else{const newPlate = new Plate2D(`PLATE-${plates.length + 1}`,plateWidth,plateHeight);const fit = this.findBestFitForPlate(item,newPlate);if(fit){if(fit.rotated)item.rotate();newPlate.placeItem(item,fit.x,fit.y);plates.push(newPlate)}}}return plates}findBestFitForPlate(item,plate){let bestFit = null;for(let rotated = 0;rotated <(item.canRotate ? 2 :1);rotated++){const currentItem = new CuttingItem2D(item.id,item.width,item.height,1,item.canRotate);if(rotated === 1)currentItem.rotate();for(const rect of plate.freeRects){if(currentItem.width <= rect.width && currentItem.height <= rect.height){const score = Math.round(rect.width * rect.height - currentItem.area);if(!bestFit || score < bestFit.score){bestFit ={x:Math.round(rect.x),y:Math.round(rect.y),rotated:rotated === 1,score}}}}}return bestFit}}class CustomOptimizer{constructor(mode = 'ff-ca-01',algorithm = 'first-fit'){this.mode = mode;this.algorithm = algorithm;this.stats ={placementsAttempted:0,placementsSuccessful:0,cacheHits:0,cacheMisses:0,executionTime:0}}validateFFCA01Configuration(params){const{smallRingA,bigRingA,smallRingB,bigRingB}= params;if(smallRingA < 0 || bigRingA < 0 || smallRingB < 0 || bigRingB < 0){return{isValid:false,message:'Error:Nilai tidak boleh negatif. Harap masukkan nilai 0 atau lebih besar.'}}const isSRAFilled = smallRingA > 0;const isSRBFilled = smallRingB > 0;const isBRAFilled = bigRingA > 0;const isBRBFilled = bigRingB > 0;if(isSRAFilled !== isSRBFilled){return{isValid:false,message:'Error:Jika mengisi Small Ring(SR),maka SR-A dan SR-B harus diisi keduanya.'}}if(isBRAFilled !== isBRBFilled){return{isValid:false,message:'Error:Jika mengisi Big Ring(BR),maka BR-A dan BR-B harus diisi keduanya.'}}const isSREmpty = !isSRAFilled && !isSRBFilled;const isBREmpty = !isBRAFilled && !isBRBFilled;const isSRComplete = isSRAFilled && isSRBFilled;const isBRComplete = isBRAFilled && isBRBFilled;const isValid1 = isSREmpty && isBRComplete;const isValid2 = isSRComplete && isBREmpty;const isValid3 = isSRComplete && isBRComplete;if(!isValid1 && !isValid2 && !isValid3){return{isValid:false,message:'Error:Konfigurasi tidak valid. Pilihan yang valid:1)SR-A dan SR-B tidak terisi,BR-A dan BR-B terisi,2)SR-A dan SR-B terisi,BR-A dan BR-B tidak terisi,3)Semua terisi(SR-A,SR-B,BR-A,BR-B).'}}return{isValid:true,message:''}}generateFFCA01Items(params){const{smallRingA,bigRingA,smallRingB,bigRingB,multiplier = 1,kerfWidth = 0}= params;const items =[];if(smallRingA > 0){items.push({id:'A-Small',length:parseInt(smallRingA)+ parseInt(kerfWidth),quantity:4 * parseInt(multiplier),originalLength:parseInt(smallRingA),type:'small-ring',pattern:'A'})}if(bigRingA > 0){items.push({id:'A-Big',length:parseInt(bigRingA)+ parseInt(kerfWidth),quantity:4 * parseInt(multiplier),originalLength:parseInt(bigRingA),type:'big-ring',pattern:'A'})}if(smallRingB > 0){items.push({id:'B-Small',length:parseInt(smallRingB)+ parseInt(kerfWidth),quantity:4 * parseInt(multiplier),originalLength:parseInt(smallRingB),type:'small-ring',pattern:'B'})}if(bigRingB > 0){items.push({id:'B-Big',length:parseInt(bigRingB)+ parseInt(kerfWidth),quantity:4 * parseInt(multiplier),originalLength:parseInt(bigRingB),type:'big-ring',pattern:'B'})}return items.filter(item => item.length > 0 && item.quantity > 0)}calculatePatternEfficiency(bars,items){const patternTotals ={A:{totalLength:0,usedLength:0},B:{totalLength:0,usedLength:0}};items.forEach(item =>{if(item.pattern === 'A'){patternTotals.A.totalLength += parseInt(item.originalLength)* parseInt(item.quantity)}else if(item.pattern === 'B'){patternTotals.B.totalLength += parseInt(item.originalLength)* parseInt(item.quantity)}});bars.forEach(bar =>{bar.items.forEach(item =>{const pattern = item.originalId.charAt(0);if(pattern === 'A'){patternTotals.A.usedLength += parseInt(item.originalLength)}else if(pattern === 'B'){patternTotals.B.usedLength += parseInt(item.originalLength)}})});const efficiencyA = patternTotals.A.totalLength > 0 ? Math.round((patternTotals.A.usedLength / patternTotals.A.totalLength)* 100):0;const efficiencyB = patternTotals.B.totalLength > 0 ? Math.round((patternTotals.B.usedLength / patternTotals.B.totalLength)* 100):0;return{A:{totalLength:parseInt(patternTotals.A.totalLength),usedLength:parseInt(patternTotals.A.usedLength),efficiency:efficiencyA},B:{totalLength:parseInt(patternTotals.B.totalLength),usedLength:parseInt(patternTotals.B.usedLength),efficiency:efficiencyB}}}optimizeFFCA01(params,materialLength = 6000){const startTime = Date.now();const validation = this.validateFFCA01Configuration(params);if(!validation.isValid){throw new Error(validation.message)}const customItems = this.generateFFCA01Items(params);if(customItems.length === 0){throw new Error("No valid items generated from FF-CA-01 parameters")}const integerItems = customItems.map(item =>({...item,length:parseInt(item.length),quantity:parseInt(item.quantity),originalLength:parseInt(item.originalLength)}));const integerMaterialLength = parseInt(materialLength);const optimizer = new CuttingOptimizer1D(this.algorithm);const result = optimizer.optimize(integerItems,integerMaterialLength);result.totalBars = parseInt(result.totalBars || 0);result.totalItems = parseInt(result.totalItems || 0);result.totalUsedLength = parseInt(result.totalUsedLength || 0);result.totalWaste = parseInt(result.totalWaste || 0);result.overallEfficiency = Math.round(result.overallEfficiency || 0);result.executionTime = parseInt(result.executionTime || 0);if(result.bars && Array.isArray(result.bars)){result.bars.forEach(bar =>{bar.usedLength = parseInt(bar.usedLength || 0);bar.remainingLength = parseInt(bar.remainingLength || 0);bar.efficiency = Math.round(bar.efficiency || 0);bar.wastePercentage = Math.round(bar.wastePercentage || 0);if(bar.items && Array.isArray(bar.items)){bar.items.forEach(item =>{item.originalLength = parseInt(item.originalLength || 0);item.length = parseInt(item.length || 0)})}})}result.mode = this.mode;result.customParams ={smallRingA:parseInt(params.smallRingA || 0),bigRingA:parseInt(params.bigRingA || 0),smallRingB:parseInt(params.smallRingB || 0),bigRingB:parseInt(params.bigRingB || 0),multiplier:parseInt(params.multiplier || 1),kerfWidth:parseInt(params.kerfWidth || 0)};result.generatedItems = integerItems;result.materialLength = integerMaterialLength;const totalCuts = integerItems.reduce((sum,item)=> sum + parseInt(item.quantity),0);const totalPatterns ={A:integerItems.filter(item => item.pattern === 'A').reduce((sum,item)=> sum + parseInt(item.quantity),0),B:integerItems.filter(item => item.pattern === 'B').reduce((sum,item)=> sum + parseInt(item.quantity),0)};result.customStats ={totalCuts:parseInt(totalCuts),totalPatterns:{A:parseInt(totalPatterns.A),B:parseInt(totalPatterns.B)},cutsPerPattern:Math.round(totalCuts / 2),efficiencyByPattern:this.calculatePatternEfficiency(result.bars,integerItems)};result.executionTime = parseInt(Date.now()- startTime);this.stats.executionTime = result.executionTime;return result}}window.CuttingOptimizer1D = CuttingOptimizer1D;window.PlateOptimizer2D = PlateOptimizer2D;window.Bar1D = Bar1D;window.Plate2D = Plate2D;window.CustomOptimizer = CustomOptimizer;